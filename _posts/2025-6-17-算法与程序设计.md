---
layout:     post   				    # 使用的布局（不需要改）
title:      算法与程序设计				# 标题 
subtitle:   算法，启动！
date:       2025-6-17				# 时间
author:     Elberich 						# 作者
header-img: img/post-bg-cook.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 算法
    - 程序设计
---


# 算法与数据结构

## 复杂度分析

**大O符号**：$$
T(n) = O(f(n))
$$

**大Ω符号**：$$
T(n) = \Omega(f(n))
$$

**大Θ符号**：$$
T(n) = \Theta(f(n))
$$

| 符号 | 描述 | 意义 | 关系 | 表达式 |
|------|------|------|------|--------|
| \( O \) | 上界 | 函数增长不超过某速度 | $ f(n) \leq C \cdot g(n) $ | $ f = O(g) $ |
| \( \Omega \) | 下界 | 函数增长至少某速度 | $ f(n) \geq C \cdot g(n) $ | $ f = \Omega(g) $ |
| \( \Theta \) | 紧确界 | 函数增长等于某速度 | $ C_1 \cdot g(n) \leq f(n) \leq C_2 \cdot g(n) $ | $ f = \Theta(g) $ |

## 分治法

### 分治法思想

- **分解**：将问题分解为更小的子问题。
- **解决**：递归地解决子问题。
- **合并**：将子问题的解合并为原问题的解。

### 时间复杂度

考虑一个递归算法，逐层二分，层中元素从 \( n \) 到 1，其递归深度 \( d \) 满足：

$$
\frac{n}{2^d} = 1
$$

解此方程得：

$$
d = \log_2 n
$$

每层递归最多需要处理  n 次运算。因此，总的运算次数为：

$$
n \log_2 n
$$

所以，时间复杂度为：

$$
O(n \log n)
$$

### 主定理

主定理适用于求解如下递归式算法的时间复杂度：

$$
T(n) = aT\left(\frac{n}{b}\right) + f(n)
$$

其中：

- \( n \) 是问题规模大小。
- \( a \) 是原问题的子问题个数。
- \( n/b \) 是每个子问题的大小。
- \( f(n) \) 是将原问题分解成子问题和将子问题的解合并成原问题的解的时间。

对上面的式子进行分析，得到三种情况：

1. 若 \( f(n) = O(n^{\log_b a - \epsilon}) \)，其中 \( \epsilon > 0 \) 是某个常数，则 \( T(n) = \Theta(n^{\log_b a}) \)。

2. 若 \( f(n) = \Theta(n^{\log_b a} \log^k n) \)，其中 \( k \geq 0 \)，则 \( T(n) = \Theta(n^{\log_b a} \log^{k+1} n) \)。

3. 若 \( f(n) = \Omega(n^{\log_b a + \epsilon}) \)，其中 \( \epsilon > 0 \)，并且 \( f(n) \) 满足正则条件：对于某个常数 \( c < 1 \) 和所有足够大的 \( n \)，有 \( a f(n/b) \leq c f(n) \)，则 \( T(n) = \Theta(f(n)) \)。

### 递归方程

简单地说，设  a, b, c  是非负常数， n  是  c  的整幂，$ f(n) $ 为线性，则递归方程：

$$
T(n) =
\begin{cases} 
c & , \quad n = 1 \\
aT\left(\frac{n}{b}\right) + bn & , \quad n > 1
\end{cases}
$$

的解为：

$$
T(n) =
\begin{cases} 
O(n), & a < b \\
O(n \log_2 n), & a = b \\
O(n \log_b a), & a > b
\end{cases}
$$

当 \( f(n) \) 为常数时：

如果在方程

$$
T(n) =
\begin{cases} 
O(1) & n = 1 \\
kT(n/m) + f(n) & n > 1
\end{cases}
$$

\( n \) 是 \( m \) 的整幂，即 $ n = m^i $，则：

$$
T(n) =
\begin{cases} 
O(n^{\log_m k}) & k \neq 1 \\
O(\log_m n) & k = 1
\end{cases}
$$

## 动态规划

动态规划常常适用于有重叠子问题和最优子结构性质的问题。基本思想是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。若用分治法来解这类问题，则分解得到的问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。

动态规划算法的有效性依赖于问题本身所具有的三个重要性质：

1. **最优子结构**：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
2. **无后效性**：即某阶段状态一旦确定，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，只与当前状态有关。
3. **重叠子问题**：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。（该性质并不是必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

## 贪心算法

### 引入与活动时间，非01背包

贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。

- **贪心选择性质**：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。
  - 贪心法仅在当前状态下做出最好选择，即局部最优选择，然后再去求解做出这个选择后产生的相应子问题的解。
  - 由多个局部可以得到整体最优。
- **最优子结构性质**：
  - 如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。
  - 问题的最优子结构性质是该问题可用动态规划算法或贪心法求解的关键特征。
  - 整体最优解包含子问题的最优。
 
### 例子

#### 活动选择问题

**问题描述**：假设有一个需要使用某一资源的 \( n \) 个活动所组成的集合 \( S \)，\( S = \{1, \ldots, n\} \)。该资源任何时刻只能被一个活动所占用，活动 \( i \) 有一个开始时间 \( b_i \) 和结束时间 \( e_i \) \( (b_i < e_i) \)，其执行时间为 \( e_i - b_i \)。一旦某个活动开始执行，中间不能被打断，直到其执行完毕。若活动 \( i \) 和活动 \( j \) 有 \( b_i \geq e_j \) 或 \( b_j \geq e_i \)，则称这两个活动兼容。设计求一种最优活动安排方案，使得所有安排的活动个数最多。

**解决方案**：

例如，对于下表的 \( n = 11 \) 个活动（已按结束时间递增排序）：

| 活动 | 开始时间 | 结束时间 |
|------|----------|----------|
| 1    | 1        | 4        |
| 2    | 3        | 5        |
| 3    | 0        | 6        |
| 4    | 5        | 7        |
| 5    | 3        | 8        |
| 6    | 5        | 9        |
| 7    | 6        | 10       |
| 8    | 8        | 11       |
| 9    | 8        | 12       |
| 10   | 2        | 13       |
| 11   | 12       | 15       |

产生最大兼容活动集合的过程：

| 活动 | 选择情况 |
|------|----------|
| 1    | √        |
| 2    | ×        |
| 3    | ×        |
| 4    | √        |
| 5    | ×        |
| 6    | ×        |
| 7    | ×        |
| 8    | √        |
| 9    | ×        |
| 10   | ×        |
| 11   | √        |

最大兼容活动集合：活动 1，活动 4，活动 8，活动 11

#### 非01背包问题

**问题描述**：设有编号为 1, 2, \ldots, \( n \) 的 \( n \) 个物品，它们的重量分别为 \( w_1, w_2, \ldots, w_n \)，价值分别为 \( v_1, v_2, \ldots, v_n \)，其中 \( w_i, v_i \ (1 \leq i \leq n) \) 均为正数。背包携带的最大重量不超过 \( W \)。求解目标：在不超过负重的前提下，使装入的总价值最大，与0/1背包问题的区别是，每个物品可以取一部分装入背包。

**解决方案**：

贪心策略：有3种可供选择。

1. 选择价值最大的物品，可以尽可能快地增加背包的总价值。但背包容量可能消耗得太快，使得装入背包的物品个数减少，不能保证目标函数达到最大。
2. 选择重量轻的物品，可以装入尽可能多的物品，从而增加背包的总价值。但这虽然使背包的容量消耗得慢了，价值却不能保证迅速增长，不能保证目标函数达到最大。
3. 选择单位重量价值最大的物品，在背包价值增长和背包容量消耗之间寻找平衡。

第（3）种策略最优。每次选择单位重量价值最大的物品，如果其重量小于背包容量，就装入，并将容量减去该物品的重量，然后就面临了一个最优子问题——它同样是背包问题，只不过背包容量减少了，物品集合减少了。因此背包问题具有最优子结构性质。

对于下表一个背包问题，\( n = 5 \)，设背包容量 \( W = 100 \)，其求解过程如下：

| \( i \) | \( w_i \) | \( v_i \) | \( v_i/w_i \) |
|---------|-----------|-----------|---------------|
| 1       | 30        | 66        | 2.2           |
| 2       | 10        | 20        | 2.0           |
| 3       | 20        | 30        | 1.5           |
| 4       | 50        | 60        | 1.2           |
| 5       | 40        | 40        | 1.0           |

将单位价值即 \( v_i/w_i \) 递减排序，其结果为 \(\{66/30, 20/10, 30/20, 60/50, 40/40\}\)，物品重新按1～5编号。

| \( i \) | \( w_i \) | \( v_i \) | \( v_i/w_i \) |
|---------|-----------|-----------|---------------|
| 1       | 30        | 66        | 2.2           |
| 2       | 10        | 20        | 2.0           |
| 3       | 20        | 30        | 1.5           |
| 4       | 50        | 60        | 1.2           |
| 5       | 40        | 40        | 1.0           |

#### 哈夫曼编码问题

**问题描述**：设要编码的字符集为 \(\{d_1, d_2, \ldots, d_n\}\)，它们出现的频率为 \(\{w_1, w_2, \ldots, w_n\}\)，应用哈夫曼树构造最优的不等长的由0、1构成的编码方案。

**哈夫曼树的知识点**：哈夫曼树的定义：设二叉树具有 \( n \) 个带权值的叶子结点，从根结点到每个叶子结点都有一个路径长度。从根结点到各个叶子结点的路径长度与相应结点权值的乘积的和称为该二叉树的带权路径长度，记作：

$$
WPL = \sum_{i=1}^{n} w_i \times l_i
$$

由 \( n \) 个叶子结点可以构造出多种二叉树，其中具有最小带权路径长度的二叉树称为哈夫曼树（也称最优树）。

## 最短路径问题

### Dijkstra算法

每次选取最近的点向前更新

### Bellman-Ford最短路径算法

**目标**：找到从起点到所有其他点的最短路径。

**核心思想**：不断尝试更新所有的边，直到所有可能的最短路径都被找到。

**思路**：

1. 初始化距离：起点为 0，其他点为无穷大。
2. 执行 \( V-1 \) 轮松弛操作：遍历所有边，更新最短距离。收敛后可获得最短路径。
3. 检测负权环：额外遍历一次！若仍可更新，则存在负权环。
