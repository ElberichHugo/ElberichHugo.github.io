---
layout:     post   				    # 使用的布局（不需要改）
title:      算法与程序设计				# 标题 
subtitle:   
date:       2025-6-18				# 时间
author:     Elberich 						# 作者
header-img: img/post-bg-cook.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 算法
    - 程序设计
---


# 算法与数据结构

## 复杂度分析

**大O符号**：

$$
T(n) = O(f(n))
$$

**大Ω符号**：

$$
T(n) = \Omega(f(n))
$$

**大Θ符号**：

$$
T(n) = \Theta(f(n))
$$

| 符号 | 描述 | 意义 | 关系 | 表达式 |
|------|------|------|------|--------|
| \( O \) | 上界 | 函数增长不超过某速度 | \( f(n) \leq C \cdot g(n) \) | \( f = O(g) \) |
| \( \Omega \) | 下界 | 函数增长至少某速度 | \( f(n) \geq C \cdot g(n) \) | \( f = \Omega(g) \) |
| \( \Theta \) | 紧确界 | 函数增长等于某速度 | \( C_1 \cdot g(n) \leq f(n) \leq C_2 \cdot g(n) \) | \( f = \Theta(g) \) |

## 分治法

### 分治法思想

- **分解**：将问题分解为更小的子问题。
- **解决**：递归地解决子问题。
- **合并**：将子问题的解合并为原问题的解。

### 时间复杂度

考虑一个递归算法，逐层二分，层中元素从 \( n \) 到 1，其递归深度 \( d \) 满足：

$$
\frac{n}{2^d} = 1
$$

解此方程得：

$$
d = \log_2 n
$$

每层递归最多需要处理 \( n \) 次运算。因此，总的运算次数为：

$$
n \log_2 n
$$

所以，时间复杂度为：

$$
O(n \log n)
$$

### 主定理

主定理适用于求解如下递归式算法的时间复杂度：

$$
T(n) = aT\left(\frac{n}{b}\right) + f(n)
$$

其中：

- \( n \) 是问题规模大小。
- \( a \) 是原问题的子问题个数。
- \( n/b \) 是每个子问题的大小。
- \( f(n) \) 是将原问题分解成子问题和将子问题的解合并成原问题的解的时间。

对上面的式子进行分析，得到三种情况：

1. 若 \( f(n) = O(n^{\log_b a - \epsilon}) \)，其中 \( \epsilon > 0 \) 是某个常数，则 \( T(n) = \Theta(n^{\log_b a}) \)。

2. 若 \( f(n) = \Theta(n^{\log_b a} \log^k n) \)，其中 \( k \geq 0 \)，则 \( T(n) = \Theta(n^{\log_b a} \log^{k+1} n) \)。

3. 若 \( f(n) = \Omega(n^{\log_b a + \epsilon}) \)，其中 \( \epsilon > 0 \)，并且 \( f(n) \) 满足正则条件：对于某个常数 \( c < 1 \) 和所有足够大的 \( n \)，有 \( a f(n/b) \leq c f(n) \)，则 \( T(n) = \Theta(f(n)) \)。

### 递归方程

简单地说，设 \( a, b, c \) 是非负常数，\( n \) 是 \( c \) 的整幂，\( f(n) \) 为线性，则递归方程：

$$
T(n) =
\begin{cases} 
c & , \quad n = 1 \\
aT\left(\frac{n}{b}\right) + bn & , \quad n > 1
\end{cases}
$$

的解为：

$$
T(n) =
\begin{cases} 
O(n), & a < b \\
O(n \log_2 n), & a = b \\
O(n \log_b a), & a > b
\end{cases}
$$

当 \( f(n) \) 为常数时：

如果在方程

$$
T(n) =
\begin{cases} 
O(1) & n = 1 \\
kT(n/m) + f(n) & n > 1
\end{cases}
$$

\( n \) 是 \( m \) 的整幂，即 \( n = m^i \)，则：

$$
T(n) =
\begin{cases} 
O(n^{\log_m k}) & k \neq 1 \\
O(\log_m n) & k = 1
\end{cases}
$$

## 动态规划

动态规划常常适用于有重叠子问题和最优子结构性质的问题。基本思想是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。若用分治法来解这类问题，则分解得到的问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。

动态规划算法的有效性依赖于问题本身所具有的三个重要性质：

1. **最优子结构**：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
2. **无后效性**：即某阶段状态一旦确定，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，只与当前状态有关。
3. **重叠子问题**：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。（该性质并不是必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

## 贪心算法

### 引入与活动时间，非01背包

贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。

- **贪心选择性质**：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。
  - 贪心法仅在当前状态下做出最好选择，即局部最优选择，然后再去求解做出这个选择后产生的相应子问题的解。
  - 由多个局部可以得到整体最优。
- **最优子结构性质**：
  - 如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。
  - 问题的最优子结构性质是该问题可用动态规划算法或贪心法求解的关键特征。
  - 整体最优解包含子问题的最优。
